"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRoute = void 0;
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/naming-convention */
const types_1 = require("@lightjs/types");
const utils_1 = require("@lightjs/utils");
const aws_serverless_micro_1 = __importDefault(require("aws-serverless-micro"));
const micro_1 = require("micro");
const isServerless_1 = require("./isServerless");
function parseHTTPMethod(method) {
    if (!method)
        return 'GET';
    if (!types_1.Methods.includes(method)) {
        throw new Error(`Invalid HTTP method: ${method}`);
    }
    return method;
}
function createRoute(component) {
    const _middleware = {
        _global: [],
    };
    function useMiddleware(mw, methods) {
        const middleware = Array.isArray(mw) ? mw : [mw];
        if (!methods) {
            _middleware._global.push(...middleware);
            return;
        }
        methods.forEach((method) => {
            var _a;
            if (!_middleware[method]) {
                _middleware[method] = [];
            }
            // TODO: Is there any way to remove the optional chaining below?
            (_a = _middleware[method]) === null || _a === void 0 ? void 0 : _a.push(...middleware);
        });
    }
    const _route = component({ useMiddleware });
    /**
     * Take the handler function (with context param) and convert it to a request handler
     */
    function defaultRouteHandler(ctx) {
        const { req } = ctx;
        const method = parseHTTPMethod(req.method);
        const routeMethod = _route[method];
        if (!routeMethod) {
            throw (0, micro_1.createError)(405, 'Method Not Allowed');
        }
        const mw = [..._middleware._global, ...(_middleware[method] || [])];
        const appliedHandler = (0, utils_1.applyMiddleware)(mw, routeMethod);
        return appliedHandler(ctx);
    }
    /**
     * Export the correct request handler based on the environment
     *
     * Serverfull = request handler (with options)
     * Vercel/Next/Now = request handler
     * Netlify/AWS = AWS handler
     * Runkit = custom request handler
     */
    let routeHandler = defaultRouteHandler;
    if (isServerless_1.isServerless) {
        const requestHandler = (0, utils_1.convertHandlerFunctionToRequestHandler)(defaultRouteHandler);
        const safeGuardedRoute = (req, res) => (0, micro_1.run)(req, res, requestHandler);
        if (isServerless_1.isNow || isServerless_1.isVercel || isServerless_1.isNextJS) {
            routeHandler = safeGuardedRoute;
        }
        if (isServerless_1.isNetlify || isServerless_1.isAWS) {
            routeHandler = {
                handler: (0, aws_serverless_micro_1.default)(safeGuardedRoute),
            };
        }
        if (isServerless_1.isRunKit) {
            routeHandler = {
                endpoint: safeGuardedRoute,
            };
        }
    }
    return routeHandler;
}
exports.createRoute = createRoute;
