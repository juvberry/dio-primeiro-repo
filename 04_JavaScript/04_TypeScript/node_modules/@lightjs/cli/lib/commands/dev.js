"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.builder = exports.desc = exports.command = void 0;
const path_1 = require("path");
const emojic_1 = __importDefault(require("emojic"));
const chalk_1 = __importDefault(require("chalk"));
const decache_1 = __importDefault(require("decache"));
const config_1 = require("@lightjs/config");
const server_1 = require("@lightjs/server");
const logger_1 = require("@lightjs/logger");
exports.command = 'dev';
exports.desc = 'start a development server';
exports.builder = {
    port: {
        alias: 'p',
        description: 'specify which port the server should run on',
    },
};
const handle = async (argv) => {
    const ts = (0, config_1.isTypescript)();
    if (ts) {
        require('ts-node').register(); // eslint-disable-line
    }
    const logger = (0, logger_1.useFrameworkLogger)();
    const middlewareConfig = (0, config_1.importMiddlewareConfig)();
    const globalMiddleware = (middlewareConfig === null || middlewareConfig === void 0 ? void 0 : middlewareConfig().global) || [];
    ((logger === null || logger === void 0 ? void 0 : logger.info) || console.info)(`[ ${chalk_1.default.redBright('start')} ] ${emojic_1.default.fire} igniting the server ${emojic_1.default.fire}`);
    /**
     * NOTE: We import youchMiddleware like this because it contains the use of the logger.
     * Using the logger requires the import of the light config which may be in typescript.
     * Since we initialize ts-node above, we need to make sure the youch import is after.
     */
    // eslint-disable-next-line global-require
    const { youchMiddleware } = require('../middleware/youch');
    const cwd = process.cwd();
    const app = (0, server_1.createServer)({
        middleware: [youchMiddleware, ...globalMiddleware],
    });
    const { HOST = '0.0.0.0' } = process.env;
    let { PORT = 3000 } = process.env;
    if (argv.port) {
        PORT = argv.port;
    }
    app.server.listen(PORT, HOST, () => {
        logger.info(`[ ${chalk_1.default.magentaBright('listening')} ] on port ${PORT}`);
        logger.info(`[ ${chalk_1.default.blueBright('hmr')} ] starting the hot reloader`);
        const chokidar = require('chokidar'); // eslint-disable-line
        const watcher = chokidar.watch(cwd, {
            ignored: ['**/node_modules/**/*', '**/node_modules/**/.*', '**/.git/**/*'],
        });
        let { importedRoutes } = app;
        watcher.on('ready', () => {
            logger.info(`[ ${chalk_1.default.blueBright('hmr')} ] watching for changes`);
        });
        watcher.on('change', async (p) => {
            logger.info(`[ ${chalk_1.default.blueBright('hmr')} ] swapping out ${chalk_1.default.yellow((0, path_1.relative)(cwd, p))}`);
            // remove edited file from cache
            (0, decache_1.default)(p);
            // decache all routes
            importedRoutes.forEach((x) => {
                (0, decache_1.default)(x.file);
            });
            process.removeAllListeners();
            // reload the server
            importedRoutes = app.reload();
        });
    });
};
const handler = (argv) => {
    handle(argv).catch((err) => {
        console.error(err);
        process.exit(1);
    });
};
exports.handler = handler;
